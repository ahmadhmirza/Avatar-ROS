#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jan 30 13:59:39 2020

@author: ahmad
"""
import cv2
import os
from os import walk
from natsort import natsorted, ns
import numpy as np
from numpy import array
##################
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
##################


MAX_IMAGES_IN_SEQUENCE = 42  
IMAGESIZE=[224,224]


class_Mappings= {
        "w01" : [0,"Start"],
        "w02" : [0,"Stop"],
        "w03" : [0,"Hello"],
        "p01" : [1,"How are you?"],
        "p02" : [2,"Nice to meet you?"],
        "p03" : [3,"Thank you!"],
        "c00" : [0,"Unclassified"]
        }

"""
Function to Read images from a directory
Reads in .jpg format
resizes the images to the size defined by IMAGESIZE constant

PARAM   : Path to read images from
RETURN  : A list of images
"""
def readImagesInPath(path):
    fileList=[]
    img_Names_List=[]
    images=[]
    for (dirpath, dirnames, filenames) in walk(path):
        #Read all the images in the current directory
        #arrange them in the list by name so the sequence in maintained
        fileList.extend(filenames)
        fileList=natsorted(fileList, alg=ns.IGNORECASE)
        #Read the image in the openCV array
        for element in fileList:
            if ".jpg" in element:
                img_Names_List.append(element)
        for image in img_Names_List:
            image_path = os.path.join(path,image)
            img = cv2.imread(image_path,cv2.IMREAD_GRAYSCALE)
            #plt.show(img)
            if img is not None:
                img=cv2.resize(img,(IMAGESIZE[0],IMAGESIZE[1]))
                images.append(img)
        return images
    
    
"""
To train the model expects the input of a constant size
This function adds 0 array as image to the list as padding
OR removes extra images

PARAM   : 
        Threshold : total allowed number of images
        ImageSequence: List of images to which padding is to be applied
        
RETURN  : Updated list of images with padding
"""
def make_zeros(n_rows: int, n_columns: int):
    matrix = []
    for i in range(n_rows):
        matrix.append([0] * n_columns)
    return matrix

def addPadding(threshold,ImageSequence):
    length = len(ImageSequence)
    count = abs(threshold -length)
    PaddingMatrix = make_zeros(IMAGESIZE[0],IMAGESIZE[1])
    
    pendulum = 0
    
    if(length<threshold):
        print(str(count) + " Images will be added as padding.")
        for x in range(0,count):
            if pendulum == 0:
                ImageSequence.insert(0,PaddingMatrix)
                pendulum = 1
            elif pendulum == 1:
                ImageSequence.append(PaddingMatrix)
                pendulum = 0
    if(length>threshold):
        print(str(count) + " Images will be removed and not considered.")
        for x in range(0,count):
            if pendulum == 0:
                del ImageSequence[0]
                pendulum = 1
            elif pendulum == 1:
                ind = len(ImageSequence)-1
                del ImageSequence[ind]
                pendulum = 0
    return ImageSequence


"""
Function to create TF model

PARAM   : 
        x - Training Data
        y - Classification Data
        epoch - INT - Number of epochs
        length - number of neurons
        
RETURN  : xxxx
"""
def Model(x,y,epoch,length):
    n_neurons = 1000
    n_batch = 10
    n_epoch = 200
    # create LSTM
    model = Sequential()
    model.add(LSTM(n_neurons, input_shape=(x.shape[1], x.shape[2])))
    model.add(Dense(1))
    model.compile(loss='mean_squared_error', optimizer='adam')
    print(model.summary())
    # train LSTM
    model.fit(x, y, epochs=n_epoch, batch_size=n_batch, verbose=2)
    # evaluate
    result = model.predict(x, batch_size=n_batch, verbose=0)
    for value in result:
    	print('%.1f' % value)

"""
Function to reshape array to required 3-d shape
PARAM   : 
        Input array, 
        Number of Samples, 
        TimeStep, 
        Features
RETURN  : Reshaped array
"""        
def reshapeArray_1(array,samples,timeStep,features):
    x= array.reshape(SAMPLES,TIME_STEP,FEATURES)
    return x
        

SAMPLES     = 130
TIME_STEP   = MAX_IMAGES_IN_SEQUENCE
FEATURES    = IMAGESIZE[0]*IMAGESIZE[1]

DATA_SET_PATH = r"/home/ahmad/Desktop/Avatar_LipReading_DataSet/sequenceData/"

Data_Info = {
        "p01": [50,"p01",1],
        "p02": [40,"p02",2],
        "p03": [40,"p03",3]
        }

samplesList = []
y_data =[]
for item in  Data_Info:
    print(item)
    dataPath        =   os.path.join(DATA_SET_PATH,item)
    numberOfSubDirectories  =   Data_Info[item][0]
    classMapping  =   Data_Info[item][2]
    
    for sample in range(1,numberOfSubDirectories+1):
        samplePath = os.path.join(dataPath,str(sample)+"/")
        #print("Reading Images from:")
        #print(samplePath)
        sample = readImagesInPath(samplePath)
        sample_padded=addPadding(MAX_IMAGES_IN_SEQUENCE,sample)
        #convert list to array:
        sample_array=np.asarray(sample_padded)
        samplesList.append(sample_array)
        y_data.append(classMapping)

trainingData = np.array([])
for item in samplesList:
    trainingData = np.append(trainingData, item)   
    
TrainingData_FINAL=reshapeArray_1(trainingData,SAMPLES,TIME_STEP,FEATURES)


x  = TrainingData_FINAL
y  = y_data


Model(x,y,300,36)
   
#def main():
#    seq1_path = r'/home/ahmad/Desktop/TrainImages/1/'
#    seq2_path = r'/home/ahmad/Desktop/TrainImages/2/'
#    
#    seq_1=readImagesInPath(seq1_path)
#
#    seq_2=readImagesInPath(seq2_path)
#    
#    print(len(seq_1))
#    print(len(seq_2))
#
#    
#if __name__ == "__main__":
#    main()